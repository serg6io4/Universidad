-- EJERCICIO 1
/*Modificar el modelo (si es necesario) para almacenar el usuario de Oracle que cada empleado o cliente pueda
utilizar para conectarse a la base de datos. Además habrá de crear roles dependiendo del tipo de usuario:
Administrativo, con acceso a toda la BD; Empleado, con acceso sólo a aquellos objetos que precise para su
trabajo (y nunca podrá acceder a los datos de otros empleados); y Cliente, con acceso sólo a los datos propios,
de su vehículo y de sus servicios. Los roles se llamarán R_ADMINISTRATIVO, R_MECANICO, R_CLIENTE.
*/


CREATE ROLE R_CLIENTE;
CREATE ROLE R_ADMINISTRATIVO;
CREATE ROLE R_MECANICO;

--Damos permisos al administrativo
GRANT CONNECT, CREATE ANY TABLE, DROP ANY TABLE, SELECT ANY TABLE, UPDATE ANY TABLE TO R_ADMINISTRATIVO;

-- Damos los permisos al mecánico. 
GRANT CONNECT TO R_MECANICO;
GRANT SELECT ON FACTURA TO R_MECANICO;
GRANT SELECT ON SERVICIO TO R_MECANICO;

--CREAMOS LA VISTA PARA QUE SOLO VEA SUS DATOS PROPIOS, NO LOS DEL RESTO. 
CREATE OR REPLACE VIEW V_DATOSPROPIOS_EMPLEADO AS (SELECT "USERNAME","NOMBRE","APELLIDO1","APELLIDO2","SUELDOBASE", "RETENCIONES", "HORAS" 
FROM EMPLEADO WHERE UPPER(USERNAME) = USER);

GRANT SELECT ON V_DATOSPROPIOS_EMPLEADO TO R_MECANICO;

--PROBAMOS LOS DATOS DE MANERA MANUAL: 
UPDATE EMPLEADO SET USERNAME = 'JUANITO' WHERE IDEMPLEADO = 13;
SELECT "USERNAME","NOMBRE","APELLIDO1","APELLIDO2","SUELDOBASE", "RETENCIONES", "HORAS" 
FROM EMPLEADO WHERE UPPER(USERNAME) = 'JUANITO';

--Nos dice que el cliente solamente puede ver sus propios datos. 
--No podemos dar permisos sobre una consulta, por esto, es necesario
--Crear una vista. A parte, hemos visto conveniente crear un atributo
--llamado username. Esto se debe a que pueden existir varias personas
--que se llamen igual. 
ALTER TABLE CLIENTE ADD USERNAME VARCHAR2(32);
ALTER TABLE EMPLEADO ADD USERNAME VARCHAR(32);

CREATE OR REPLACE VIEW V_DATOSPROPIOS AS (SELECT "USERNAME","TELEFONO","NOMBRE","APELLIDO1","APELLIDO2","EMAIL" FROM AUTORACLE.CLIENTE WHERE UPPER(USERNAME) = USER);

--Estos son los datos que vimos convenientes que se le mostraran al cliente respecto a los datos de su propio vehículo.
CREATE OR REPLACE VIEW V_MIVEHICULO AS (SELECT V.NUMBASTIDOR, V.MATRICULA, V.FABRICACION, V.KILOMETRAJE, M.NOMBRE AS MARCA, MO.NOMBRE AS MODELO, MO.COMBUSTIBLE FROM VEHICULO V, MARCA M, MODELO MO, CLIENTE C 
WHERE C.IDCLIENTE = V.CLIENTE_IDCLIENTE AND M.IDMARCA = V.MODELO_MARCA_IDMARCA AND MO.IDMODELO = V.MODELO_IDMODELO AND UPPER(USERNAME) = USER); 

CREATE OR REPLACE VIEW V_MISERVICIO AS(
SELECT V.MATRICULA AS MATRICULA, V.NUMBASTIDOR  "NUMERO DE BASTIDOR", S.ESTADO AS ESTADO, S.OBSCHAPA "DEFECTO DE CHAPA", S.FECAPERTURA "FECHA APERTURA", 
S.FECRECEPCION "FECHA RECEPCIÓN", S.FECREALIZACION "FECHA REALIZACIÓN" FROM CLIENTE C, VEHICULO V, SERVICIO S 
WHERE UPPER(C.USERNAME) = USER AND V.NUMBASTIDOR = S.VEHICULO_NUMBASTIDOR AND C.IDCLIENTE = V.CLIENTE_IDCLIENTE);

--Esto son los datos que insertamos. 
INSERT INTO CLIENTE(IDCLIENTE, TELEFONO, NOMBRE, APELLIDO1, APELLIDO2, EMAIL, USERNAME) VALUES ('278', 123456789, 'Prueba', 'Apellido1Prueba', 'Apelido2Prueba','EMAIL@HOLI.COM', 'Autoracle');
INSERT INTO VEHICULO VALUES('VW2937891', '0371JKY', 2016, 14, 12, '278', 80000);
INSERT INTO SERVICIO VALUES(1234, 'Reparado', '25/05/2020', '26/05/2020', '28/05/2020', 'Bollo en el lado derecho', 'VW2937891', 10);


SELECT * FROM V_DATOSPROPIOS;
SELECT * FROM V_MIVEHICULO;
SELECT * FROM V_MISERVICIO;

--Ejercicio 2
/*Crea una tabla denominada COMPRA_FUTURA que incluya el NIF, teléfono, nombre e email del proveedor,
Referencia de pieza y cantidad. Necesitamos un procedimiento P_REVISA que cuando se ejecute compruebe si
las piezas han caducado. De esta forma, insertará en COMPRA_FUTURA aquellas piezas caducadas junto a los
datos necesarios para realizar en el futuro la compra.*/


CREATE TABLE COMPRA_FUTURA(
    NIF VARCHAR(9), 
    TELEFONO NUMBER(38,0),
    NOMBRE VARCHAR(50), 
    EMAIL_PROVEEDOR VARCHAR(50), 
    REF_PIEZA VARCHAR(50), 
    CANTIDAD NUMBER);

DROP TABLE COMPRA_FUTURA;


    
CREATE OR REPLACE PROCEDURE P_REVISA IS
    CURSOR C_PIEZA IS SELECT PROVEEDOR_NIF, CODREF, NOMBRE, CANTIDAD, FECCADUCIDAD FROM PIEZA;
    TEL number;
    EMAIL VARCHAR2(50);
BEGIN
    FOR I IN C_PIEZA LOOP
        IF(I.FECCADUCIDAD < SYSDATE) THEN
   
            SELECT EMAIL, TELEFONO INTO EMAIL,TEL FROM PROVEEDOR P WHERE I.PROVEEDOR_NIF = P.NIF;
            INSERT INTO COMPRA_FUTURA VALUES (I.PROVEEDOR_NIF, TEL, I.NOMBRE, EMAIL, I.CODREF, I.CANTIDAD);
        END IF;
    END LOOP;
    
END P_REVISA;
/


-- REALIZAMOS UN INSERT EN PIEZA CON UNA FECHA DE CADUCIDAD VENCIDA
INSERT INTO PIEZA VALUES('11112','prueba', 9999, 9999, 7, '02/05/20', 'c745269');

-- Finalmente ejecutamos el procedimiento y vemos como sale correctamente con el select.
EXECUTE P_REVISA;
SELECT * FROM COMPRA_FUTURA;

/*Añadir dos campos a la tabla factura: iva calculado y total. Implementar un procedimiento P_CALCULA_FACT que
recorre los datos necesarios de las piezas utilizadas y el porcentaje de iva y calcula la cantidad en euros para
estos dos campos. Tener en cuenta que los únicos elementos facturables son las piezas y que de cada pieza
distinta sólo puede haber UNA en la factura*/

--EJERCICIO 3
--Añadimos los campos iva total e iva calculado
ALTER TABLE FACTURA ADD (IVA_TOTAL NUMBER(38,0), IVA_CALCULADO NUMBER(38,0));
CREATE OR REPLACE VIEW V_PIEZA_CONT_FACT AS ( SELECT CODREF,PRECIOUNIDADVENTA,IDFACTURA,IVA 
FROM FACTURA F  LEFT JOIN  CONTIENE C  ON F.IDFACTURA=C.FACTURA_IDFACTURA  LEFT JOIN PIEZA P ON C.PIEZA_CODREF =P.CODREF);



SELECT * FROM V_PIEZA_CONT_FACT;


CREATE OR REPLACE PROCEDURE P_CALCULA_FACT IS

CURSOR C_VISTA IS SELECT IDFACTURA,CODREF,PRECIOUNIDADVENTA,IVA FROM V_PIEZA_CONT_FACT;

IVA_CALC NUMBER :=0 ;
IVA_TOT NUMBER :=0;

BEGIN
    UPDATE FACTURA SET IVA_TOTAL=0, IVA_CALCULADO=0;
    FOR I IN C_VISTA LOOP
        UPDATE FACTURA SET IVA_CALCULADO=IVA_CALCULADO+ (I.PRECIOUNIDADVENTA*I.IVA/100), IVA_TOTAL=IVA_TOTAL+I.PRECIOUNIDADVENTA+I.PRECIOUNIDADVENTA*I.IVA/100
        WHERE I.IDFACTURA=FACTURA.IDFACTURA ;

      /*  SELECT  (I.PRECIOUNIDADVENTA*(I.IVA/100) ) INTO IVA_CALC FROM V_PIEZA_CONT_FACT ;
        SELECT (I.PRECIOUNIDADVENTA) INTO IVA_TOT FROM V_PIEZA_CONT_FACT;
        UPDATE FACTURA SET IVA_CALCULADO = IVA_CALC, IVA_TOTAL=(IVA_TOT+IVA_CALC)WHERE I.IDFACTURA=FACTURA.IDFACTURA ;  */

    END LOOP;
END P_CALCULA_FACT;
/
EXECUTE P_CALCULA_FACT;

SELECT * FROM FACTURA;

--EJERCICIO 4
/*Necesitamos una vista denominada V_IVA_CUATRIMESTRE con los atributos AÑO, TRIMESTRE, IVA_TOTAL
siendo trimestre un número de 1 a 4. El IVA_TOTAL es el IVA devengado (suma del IVA de las facturas de ese
trimestre). Dar permiso de selección a los Administrativos.*/


CREATE OR REPLACE VIEW V_IVA_CUATRIMESTRE (AÑO, TRIMESTRE, IVA_TOTAL) AS
(SELECT TO_CHAR(FECEMISION,'YYYY'), TRUNC((TO_NUMBER(TO_CHAR(FECEMISION, 'MM'))/4)+1), SUM(IVA_CALCULADO) AS IVA_TOTAL FROM FACTURA 
GROUP BY TO_CHAR(FECEMISION,'YYYY'), TRUNC((TO_NUMBER(TO_CHAR(FECEMISION, 'MM'))/4)+1));

SELECT * FROM V_IVA_CUATRIMESTRE;
--Le tenemos que dar este permiso al administrativo.
GRANT SELECT TO R_ADMINISTRATIVO;

--EJERCICIO 5

/*Crear un paquete en PL/SQL de análisis de datos.
1. La función F_Calcular_Piezas devolverá la media, mínimo y máximo número de unidades compradas
(en cada lote) de una determinada pieza en un año concreto.
2. La función F_Calcular_Tiempos devolverá la media de días en las que se termina un servicio (Fecha de
realización – Fecha de entrada en taller) así como la media de las horas de mano de obra de los servicios
de Reparación.
3. El procedimiento P_Recompensa encuentra el servicio proporcionado más rápido y más lento (en días)
y a los empleados involucrados los recompensa con un +/- 5% en su sueldo base respectivamente. */


CREATE OR REPLACE VIEW V_MEJOR_TIEMPO AS 
(SELECT IDEMPLEADO FROM SERVICIO S,TRABAJA T, EMPLEADO E 
WHERE FECREALIZACION-FECRECEPCION = (SELECT MIN(FECREALIZACION-FECRECEPCION) FROM SERVICIO) 
AND T.EMPLEADO_IDEMPLEADO=E.IDEMPLEADO AND T.SERVICIO_IDSERVICIO=S.IDSERVICIO);

CREATE OR REPLACE VIEW V_PEOR_TIEMPO AS 
(SELECT IDEMPLEADO FROM SERVICIO S,TRABAJA T, EMPLEADO E 
WHERE FECREALIZACION-FECRECEPCION = (SELECT MAX(FECREALIZACION-FECRECEPCION) FROM SERVICIO) 
AND T.EMPLEADO_IDEMPLEADO=E.IDEMPLEADO AND T.SERVICIO_IDSERVICIO=S.IDSERVICIO);
 
SELECT * FROM V_PEOR_TIEMPO;



CREATE OR REPLACE PACKAGE ANALISIS_DATOS AS 
TYPE T_SOL1 IS RECORD(
	MEDIA NUMBER,
	MAXIMO NUMBER,
	MINIMO NUMBER
	);

TYPE T_SOL2 IS RECORD(
    MED_DIAS NUMBER,
    MED_HORAS NUMBER
	);

FUNCTION F_CALCULAR_PIEZAS(CODREFP IN VARCHAR2, AÑO IN NUMBER) RETURN T_SOL1;
FUNCTION F_CALCULAR_TIEMPOS (SERVICIO IN NUMBER) RETURN T_SOL2;
PROCEDURE P_RECOMPENSA;

END ANALISIS_DATOS;
/

create or replace PACKAGE BODY ANALISIS_DATOS AS 
    
    FUNCTION F_CALCULAR_PIEZAS(CODREFP IN VARCHAR2, AÑO IN NUMBER) RETURN T_SOL1 AS
    SOL1 T_SOL1;
        BEGIN
            SELECT AVG(NÚMERO_DE_PIEZAS), MAX(NÚMERO_DE_PIEZAS), MIN(NÚMERO_DE_PIEZAS) INTO SOL1
            FROM LOTE L JOIN COMPRA C ON L.COMPRA_IDCOMPRA = C.IDCOMPRA 
            WHERE CODREFP = L.PIEZA_CODREF AND AÑO = TO_NUMBER(TO_CHAR(C.FECRECEPCION, 'YYYY'));
        RETURN SOL1;
    END; 

    FUNCTION F_CALCULAR_TIEMPOS (SERVICIO IN NUMBER) RETURN T_SOL2 AS
    SOL2 T_SOL2;
    BEGIN
        SELECT AVG(FECREALIZACION-FECRECEPCION) INTO SOL2.MED_DIAS FROM SERVICIO WHERE IDSERVICIO = SERVICIO AND FECREALIZACION IS NOT NULL;
        SELECT AVG(HORAS) INTO SOL2.MED_HORAS FROM REPARACION R, SERVICIO S 
        WHERE R.IDSERVICIO = SERVICIO AND S.IDSERVICIO = R.IDSERVICIO AND S.FECREALIZACION IS NOT NULL;
        RETURN SOL2;
    END;

    PROCEDURE P_RECOMPENSA IS    
    CURSOR C_RECOMP IS SELECT * FROM V_MEJOR_TIEMPO;
    CURSOR C_NO_RECOMP IS SELECT * FROM V_PEOR_TIEMPO;
    BEGIN
        FOR I IN C_RECOMP LOOP
            UPDATE EMPLEADO SET SUELDOBASE = SUELDOBASE*1.05 WHERE I.IDEMPLEADO = IDEMPLEADO;
        END LOOP;
        FOR I IN C_NO_RECOMP LOOP
            UPDATE EMPLEADO SET SUELDOBASE = SUELDOBASE*0.95 WHERE I.IDEMPLEADO = IDEMPLEADO;
        END LOOP;
    END;
END ANALISIS_DATOS;
/


--EJERCICIO 6
/*Añadir al modelo una tabla FIDELIZACIÓN que permite almacenar un descuento por cliente y año. Crear un
paquete en PL/SQL de gestión de descuentos.*/

CREATE TABLE FIDELIZACION( DESCUENTO NUMBER, AÑO NUMBER);

ALTER TABLE FIDELIZACION ADD (ID_CLIENTE_FIDELIZACION VARCHAR2(16 BYTE));
ALTER TABLE FIDELIZACION ADD CONSTRAINT FK_FIDELIZACION_CLIENTE FOREIGN KEY(ID_CLIENTE_FIDELIZACION) REFERENCES CLIENTE;

/*1. El procedimiento P_Calcular_Descuento, tomará un cliente y un año y calculará el descuento del que podrá
disfrutar el año siguiente. Para ello, hasta un máximo del 10%, irá incrementando el descuento en un
1%, por cada una de las siguientes acciones:
1. Por cada servicio pagado por el cliente
2. Por cada ocasión en la que el cliente tuvo que esperar más de 5 días desde que solicitó la cita
hasta que se concertó.
3. Por cada servicio proporcionado en el que tuvo que esperar más de la media de todos los
servicios.*/

CREATE OR REPLACE  VIEW V_VEH_SERV AS
(SELECT (FECREALIZACION-FECRECEPCION)"DIAS",CLIENTE_IDCLIENTE, IDSERVICIO FROM SERVICIO S JOIN VEHICULO V ON S.VEHICULO_NUMBASTIDOR= V.NUMBASTIDOR);

--SELECT * FROM  V_VEH_SERV;
CREATE OR REPLACE PACKAGE GESTION_DESCUENTOS AS
PROCEDURE P_CALCULAR_DESCUENTO;
PROCEDURE P_APLICAR_DESCUENTO;
END GESTION_DESCUENTOS;
/
CREATE OR REPLACE PACKAGE BODY GESTION_DESCUENTOS AS

    PROCEDURE P_CALCULAR_DESCUENTO IS
   
    CURSOR C_FACTURA IS SELECT IDFACTURA,FECEMISION, CLIENTE_IDCLIENTE FROM FACTURA;
    CURSOR C_CITA IS SELECT FECHA_SOLICITUD,FECHA_CONCERTADA,CLIENTE_IDCLIENTE FROM CITA ;
    CURSOR C_VISTA IS SELECT CLIENTE_IDCLIENTE, DIAS FROM V_VEH_SERV;
    MEDIA NUMBER;
    
    BEGIN
        --PONEMOS DESCUENTO A 0 A PRINCIPIO DE AÑO
         UPDATE FIDELIZACION SET DESCUENTO=0;
    
         FOR I IN C_FACTURA LOOP
            --Si es el mismo año, añadimos un 1% de descuento a la cuenta(fidelización) del cliente. 
            IF( TO_CHAR(I.FECEMISION,'YYYY') =  TO_CHAR(sysdate, 'YYYY')) THEN
                UPDATE FIDELIZACION SET DESCUENTO= DESCUENTO+1 , AÑO=TO_NUMBER(TO_CHAR(SYSDATE,'YYYY'))+1 WHERE I.CLIENTE_IDCLIENTE= ID_CLIENTE_FIDELIZACION AND DESCUENTO<10 ;
            END IF;
         END LOOP;
        
        
         FOR I IN C_CITA LOOP
            UPDATE FIDELIZACION SET DESCUENTO= DESCUENTO+1 , AÑO=TO_NUMBER(TO_CHAR(SYSDATE,'YYYY'))+1 WHERE ((I.FECHA_CONCERTADA-I.FECHA_SOLICITUD)>5) AND DESCUENTO<10 AND I.CLIENTE_IDCLIENTE=ID_CLIENTE_FIDELIZACION;
         END LOOP;
         
        SELECT AVG(DIAS) INTO MEDIA FROM V_VEH_SERV;
        FOR I IN C_VISTA LOOP
            UPDATE FIDELIZACION SET DESCUENTO= DESCUENTO+1 , AÑO=TO_NUMBER(TO_CHAR(SYSDATE,'YYYY'))+1 WHERE (MEDIA<I.DIAS) AND DESCUENTO<10 AND I.CLIENTE_IDCLIENTE=ID_CLIENTE_FIDELIZACION ;
        END LOOP;
           
END;


/*2. El procedimiento P_Aplicar_descuento tomará el año y el cliente. Si en la tabla FIDELIZACIÓN hay un
descuento calculado a aplicar ese año, lo hará para todas las facturas que encuentre (en ese año).*/

PROCEDURE P_APLICAR_DESCUENTO IS
CURSOR C_FID IS SELECT AÑO,DESCUENTO,ID_CLIENTE_FIDELIZACION FROM FIDELIZACION;
BEGIN
   
    FOR I IN C_FID LOOP
        UPDATE FACTURA SET DESCUENTO= DESCUENTO+I.DESCUENTO WHERE I.ID_CLIENTE_FIDELIZACION=CLIENTE_IDCLIENTE AND I.AÑO=TO_NUMBER(TO_CHAR(FECEMISION,'YYYY'));
    END LOOP;
END;
END GESTION_DESCUENTOS;
/


--EJERCICIO 7
/*7. Crear un paquete en PL/SQL de gestión de empleados que incluya las operaciones para crear, borrar y modificar
los datos de un empleado. Hay que tener en cuenta que algunos empleados tienen un usuario y, por tanto, al
insertar o modificar un empleado, si su usuario no es nulo, habrá que crear su usuario. Además, el paquete
ofrecerá procedimientos para bloquear/desbloquear cuentas de usuarios de modo individual. También se debe
disponer de una opción para bloquear y desbloquear todas las cuentas de los empleados.*/

--EJERCICIO 7
CREATE OR REPLACE PACKAGE GESTION_EMPLEADO AS
PROCEDURE P_CREAR_EMPLEADO(IDEMPLEADO IN VARCHAR2,NOMBRE IN VARCHAR2,DESPEDIDO IN NUMBER,SUELDOBASE IN NUMBER,FECENTRADA IN DATE,USERNAMEP IN VARCHAR2 );

PROCEDURE P_MODIFICAR_EMPLEADO(IDEMPLEADOP IN VARCHAR2,NOMBREP IN VARCHAR2,DESPEDIDOP IN NUMBER,SUELDOBASEP IN NUMBER,FECENTRADAP IN DATE,APELLIDO1P IN VARCHAR2,APELLIDO2P IN VARCHAR2,HORASP IN NUMBER,PUESTOP IN VARCHAR2,
RETENCIONESP IN  NUMBER,USERNAMEP VARCHAR2 );

PROCEDURE P_ELIMINAR_EMPLEADO(IDEMPLEADOP IN VARCHAR2);

PROCEDURE P_BLOQUEAR(USERNAME IN VARCHAR2);
PROCEDURE P_DESBLOQUEAR(USERNAME IN VARCHAR2);
PROCEDURE P_BLOQUEAR_EMPLEADOS;
PROCEDURE P_DESBLOQUEAR_EMPLEADOS;

END GESTION_EMPLEADO;
/
CREATE OR REPLACE  PACKAGE BODY  GESTION_EMPLEADO AS
--Procedimiento crear empleado.
PROCEDURE P_CREAR_EMPLEADO (IDEMPLEADO IN VARCHAR2,NOMBRE IN VARCHAR2,DESPEDIDO IN NUMBER,SUELDOBASE IN NUMBER,FECENTRADA IN DATE,USERNAMEP IN VARCHAR2 ) IS

BEGIN
    INSERT INTO EMPLEADO(IDEMPLEADO, NOMBRE, DESPEDIDO,SUELDOBASE,FECENTRADA,USERNAME) VALUES (IDEMPLEADO, NOMBRE, DESPEDIDO, SUELDOBASE, FECENTRADA, USERNAMEP);
     IF( USERNAMEP IS NOT NULL) THEN
        EXECUTE IMMEDIATE 'CREATE USER '||USERNAMEP||' IDENTIFIED BY USENAME';
     END IF;
END;

--EXECUTE P_CREAR_EMPLEADO('993','PEP',0,1200,'03/03/2020','PEPITO');
PROCEDURE P_MODIFICAR_EMPLEADO(IDEMPLEADOP IN VARCHAR2,NOMBREP IN VARCHAR2,DESPEDIDOP IN NUMBER,SUELDOBASEP IN NUMBER,FECENTRADAP IN DATE,APELLIDO1P IN VARCHAR2,APELLIDO2P IN VARCHAR2,HORASP IN NUMBER,PUESTOP IN VARCHAR2,
RETENCIONESP IN  NUMBER,USERNAMEP VARCHAR2 ) IS
BEGIN
    
     UPDATE EMPLEADO SET NOMBRE=NOMBREP,DESPEDIDO=DESPEDIDOP, SUELDOBASE=SUELDOBASEP, FECENTRADA=FECENTRADAP,APELLIDO1=APELLIDO1P, APELLIDO2=APELLIDO2P,HORAS=HORASP,PUESTO=PUESTOP,RETENCIONES=RETENCIONESP,USERNAME=USERNAMEP WHERE EMPLEADO.IDEMPLEADO=IDEMPLEADOP;
     IF( USERNAMEP IS NOT NULL) THEN
        EXECUTE IMMEDIATE 'CREATE USER '||USERNAMEP||' IDENTIFIED BY USENAME';
     END IF;

END;

--EXECUTE P_MODIFICAR_EMPLEADO('993','EEP',0,3000,'03/03/2020','NULL','NULL',87,3,0,'PE');
--EXECUTE P_MODIFICAR_EMPLEADO('958','EEP',0,3000,'03/03/2020','NULL','NULL',87,3,0,'BASURA');

--EXECUTE P_MODIFICAR_EMPLEADO('993','EEP',0,3000,'03/03/2020','NULL','NULL',87,3,0,'PE');


PROCEDURE P_ELIMINAR_EMPLEADO(IDEMPLEADOP IN VARCHAR2) IS
BEGIN
     DELETE VACACIONES WHERE VACACIONES.EMPLEADO_IDEMPLEADO=IDEMPLEADOP;
     DELETE EMPLEADO WHERE EMPLEADO.IDEMPLEADO=IDEMPLEADOP ;
     
END;
--EXECUTE P_ELIMINAR_EMPLEADO('12');

PROCEDURE P_BLOQUEAR(USERNAME IN VARCHAR2) AS
SENTENCIA VARCHAR2 (1000);
BEGIN
   SENTENCIA:= ' ALTER USER '||  USERNAME ||' ACCOUNT LOCK';
   DBMS_OUTPUT.PUT_LINE(SENTENCIA);
   EXECUTE IMMEDIATE SENTENCIA ;

END;
--EXECUTE P_BLOQUEAR('BASURA');
-- EN SYSTEM EJECUTAR Select username,account_status from DBA_USERS PARA COMPROBAR SI SE HA BLOQUEADO ;
PROCEDURE P_DESBLOQUEAR (USERNAME IN VARCHAR2) AS
SENTENCIA VARCHAR2 (1000);
BEGIN
   SENTENCIA:= 'ALTER USER '||  USERNAME ||' ACCOUNT UNLOCK';
   DBMS_OUTPUT.PUT_LINE(SENTENCIA);
   EXECUTE IMMEDIATE SENTENCIA ;

END;
--EXECUTE P_DESBLOQUEAR('BASURA');

PROCEDURE P_BLOQUEAR_EMPLEADOS AS
CURSOR C_EMPLEADO IS SELECT USERNAME FROM EMPLEADO;
SENTENCIA VARCHAR2 (1000);
BEGIN
    FOR I IN C_EMPLEADO LOOP
    IF(I.USERNAME IS NOT NULL) THEN
     SENTENCIA:= 'ALTER USER '||  I.USERNAME ||' ACCOUNT LOCK';
     DBMS_OUTPUT.PUT_LINE(SENTENCIA);
     EXECUTE IMMEDIATE SENTENCIA ;
     END IF;
   END LOOP;
    
END;

--EXECUTE P_BLOQUEAR_EMPLEADOS;

PROCEDURE P_DESBLOQUEAR_EMPLEADOS AS
CURSOR C_EMPLEADO IS SELECT USERNAME FROM EMPLEADO;
SENTENCIA VARCHAR2 (1000);
BEGIN
    FOR I IN C_EMPLEADO LOOP
    IF(I.USERNAME IS NOT NULL) THEN
     SENTENCIA:= 'ALTER USER '||  I.USERNAME ||' ACCOUNT UNLOCK';
     DBMS_OUTPUT.PUT_LINE(SENTENCIA);
     EXECUTE IMMEDIATE SENTENCIA ;
     END IF;
   END LOOP;
    
END;

--EXECUTE P_DESBLOQUEAR_EMPLEADOS;

END GESTION_EMPLEADO;
/


-- EJERCICIO 8

/*. Escribir un trigger que cuando se eliminen los datos de un cliente fidelizado se eliminen a su vez toda su
información de fidelización y los datos de su vehículo.*/


CREATE OR REPLACE TRIGGER T_ELIMINAR_USUARIO
AFTER DELETE ON CLIENTE 
FOR EACH ROW
--POR SI TIENE MÁS DE UN VEHÍCULO HAGO FOR EACH ROW
BEGIN

    DELETE FROM VEHICULO WHERE VEHICULO.CLIENTE_IDCLIENTE=:OLD.IDCLIENTE;
    DELETE FROM FIDELIZACION WHERE FIDELIZACION.ID_CLIENTE_FIDELIZACION=:OLD.IDCLIENTE;
   
END T_ELIMINAR_USUARIO;
/


--Ejercicio 9
BEGIN
DBMS_SCHEDULER.CREATE_JOB (
job_name => 'JOB_REVISA',
job_type => 'STORED_PROCEDURE',
job_action => 'P_REVISA',
start_date => SYSDATE,
repeat_interval => 'FREQ=DAILY;BYHOUR=21',
enabled => TRUE,
auto_drop=>FALSE,
end_date=>NULL,
comments => 'Ejecuta p_revisa todos los días a las 21');
END;
--Todos los años
BEGIN
DBMS_SCHEDULER.CREATE_JOB (
job_name => 'JOB_RECOMPENSA',
job_type => 'STORED_PROCEDURE',
job_action => 'P_RECOMPENSA',
start_date => SYSDATE,
repeat_interval => 'FREQ=YEARLY;BYMONTH=DEC;BYMONTHDAY=31;BYHOUR=23;BYMINUTE=55',/*SI NO ES EL PUNTO ES EL DOBLE PUNTO*/
enabled => TRUE,
auto_drop=>FALSE,
end_date=>NULL,
comments => 'Ejecuta p_recompensa anualmente a las 23:55 del 31 de Diciembre');
END;


DBMS_SCHEDULER.DROP_JOB ('JOB_RECOMPENSA, JOB_REVISA');
